#target Illustrator/* ref code    How to open PS from Illustrator (doesn't work yet with flash)    For reference you can pass in the name of a file too i.e. Ai's active document (t)    //var t = app.activeDocument.fullName;      //photoshop.open(new File(t));    /*var numLayers = doc.layers.length;    var numArtboards = doc.artboards.length;    var rect = doc.artboards[0].artboardRect;    alert(rect);    var width = activeDocument.artboards[0].artboardRect[2];    var height = activeDocument.artboards[0].artboardRect[3];    alert(width + " | " + height);*/var doc, dest, file;var manafest = [];init();function init(){    //Get all the files we need to work on    file = new File("/Users/sjpeaster/Projects/SantaCode_2014/sourcefiles/illustrator/test.ai");    app.open(file);    //Get the Build folder destination    dest = new File("/Users/sjpeaster/Projects/SantaCode_2014/build");    //Get the active document, alert if there isn't one    resetDoc();    //Make a sprite sheet for each artboard (TODO - Ensure that sprite sheets are created in a 'free' space);    forEach(doc.artboards, genSpriteSheet);    //Save a png for each artboard    forEach(doc.artboards, function savePNG(ab, index){        doc.artboards.setActiveArtboardIndex(index);        exportPNG(doc, (dest + "/" + ab.name + ".png"), 100);    });    //doc.close(SaveOptions.DONOTSAVECHANGES);}function forEach(iterable, callback){    for (var i = iterable.length; i > 0; i--){        var index = i-1;        callback(iterable[index], index);    }}function reverseArray(array){    result = [];    forEach(array, function pushToResult(item){        result.push(item);    });    return result;}function lock(layer){    layer.locked = true;}function unlock(layer){    layer.locked = false;}function selectAll(layer){    layer.hasSelectedArtwork = false;    layer.hasSelectedArtwork = true;    return doc.selection;}function deselectAll(layer){    layer.hasSelectedArtwork = false;   }function getByName(layers, name){    var result = null;    forEach(layers, function checkName(lyr, index){        if (result != null) return;        if (lyr.name.match(name) != null) result = lyr;    });    return result;}//Set doc to the active document if one existsfunction resetDoc(){    if (app.documents.length > 0){        doc = app.activeDocument;    } else {        alert('Please open an Illustrator file');    }}function exportPNG(doc, dest, scale){    var fileSpec = new File(dest);    var type = ExportType.PNG24;    var exportOptions = new ExportOptionsPNG24();    exportOptions.antiAliasing = false;    exportOptions.artBoardClipping = true;    exportOptions.transparency = true;    exportOptions.saveAsHTML = true;    exportOptions.horizontalScale = scale;    exportOptions.verticalScale = scale;    doc.exportFile( fileSpec, type, exportOptions );}/*Source    *Verry helpful function barrowed from:    *http://greladesign.com/blog/2014/12/03/add-artboard-with-javascript-in-illustrator-cs5-1/*/function newRect(x, y, width, height) {    var l = 0;      var t = 1;      var r = 2;      var b = 3;      var rect = [];      rect[l] = x;      rect[t] = -y;      rect[r] = width + x;      rect[b] = -(height - rect[t]);    return rect;  };/* new Sprite Sheet Artboard from Artboard    *@param: ab <artboard>    *@param: index <int> the index of the artboard    *@return: <artboard>*/function newSS_Ab_fromAb(ab, index){    var curRect = ab.artboardRect;    var x = Math.ceil(curRect[0]);    var y = Math.floor(curRect[1]);    var width = Math.ceil(doc.width);    var height = Math.ceil(doc.height);    var name = ab.name;    var result;    //Make sure we have good meaningful names    if(name.match('Artboard') != null){        name = doc.name.substr(0, doc.name.length-3) + "_Ab" + index;        ab.name = name;    }    //creates a new artboard with special name    if(doc.artboards.length < 100) result = doc.artboards.add(newRect(x + width + 10, -y, width, height));    else {        alert("Too many artboards in this document."        + "\nCannot create a sprite sheet until you remove at least one artboard.");    }    result.name = name + "-SS";    return result;}/* Get's the sprite sheet layer, makes one if there isn't one yet    *@param: ssArtboard <Artboard> the Sprite Sheet Artboard    *@return: <Layer>*/function getSSLayer(ssArtboard){    var result;    if(getByName(doc.layers, ssArtboard.name) == null){        result = doc.layers.add();        result.name = ssArtboard.name;          }else{        result = getByName(doc.layers, ssArtboard.name);    }    return result;}/* Duplicates each layer's contents to a group in the SSLayer    *@param: ssLayer <Layer> the Sprite Sheet Layer    *@param: ssArtboard <Artboard> the Sprite Sheet Artboard    *@return: <Array>*/function duplicateVisibleLayersToSSLyr(ssLayer, ssArtboard){    var result = [];    var layers = doc.layers;    forEach(layers, lock);    forEach(layers, function duplicateContentsTo(lyr, index){        //NOTE!! There is no way to manipulate effects from Illustrator through js        //IT WILL ONLY KEEP EFFECTS APPLIED TO GROUPS WITHIN A LAYER ^^^        //skip if sprite sheet layer TODO        if (!lyr.visible || lyr.name == ssArtboard.name) return;        lyr.locked = false;        var lyrContents = lyr.pageItems;        ssLayer.locked = false;        //TODO Pop these groups into an array        var newGroup = ssLayer.groupItems.add();        newGroup.name = lyr.name + "_Grp";        //alert(lyrContents.visibleBounds);                for ( i = 0; i < lyrContents.length; i++ ) {            newItem = lyrContents[i].duplicate();            newItem.moveToEnd( newGroup );        }        result.push(newGroup);        ssLayer.locked = true;        lyr.locked = true;    });    return result;}function rectToObject(rect){    var result = new Object;    result.left = rect[0];    result.top = rect[1];    result.right = rect[2];    result.bottom = rect[3];    result.x = rect[0];    result.y = rect[1];    result.width = rect[2] - result.x;    result.height = -1*(rect[3] - result.y);    return result;}function updateArtboardInfo(artboard){    var rectObj = rectToObject(artboard.artboardRect);    artboard.Left = rectObj.left;    artboard.Top = rectObj.top;    artboard.Right = rectObj.right;    artboard.Bottom = rectObj.bottom;    artboard.X = rectObj.x;    artboard.Y = rectObj.y;    artboard.Width = rectObj.width;    artboard.Height = rectObj.height;    artboard.Size = rectObj.width * rectObj.height;}function updatePageItemInfo(pageItem){    //PageItem width/height props do no include strokes    var rectObj = rectToObject(pageItem.controlBounds);    pageItem.Left = rectObj.left;    pageItem.Top = rectObj.top;    pageItem.Right = rectObj.right;    pageItem.Bottom = rectObj.bottom;    pageItem.X = rectObj.x;    pageItem.Y = rectObj.y;    pageItem.Width = rectObj.width;    pageItem.Height = rectObj.height;    pageItem.Size = rectObj.width * rectObj.height;}function centerItem(pageItem){    //Assumes X/Y props are updated    pageItem.translate(-pageItem.X,-pageItem.Y);}function getMaxOfArray(numArray) {    return Math.max.apply(null, numArray);}function indexOf(iterable, item){    var result = -1;    forEach(iterable, function checkForMatch(thisItem, index){        if (result > -1) return;        if (thisItem == item) result = index;    });    return result;}function biggestToSmallest(numArray){    var result = [];    while (numArray.length > 0){        var max = getMaxOfArray(numArray);        var index = indexOf(numArray, max);        if (index > -1) {            numArray.splice(index, 1);            result.push(numArray[index]);        }    }    return result;}function itemsBigToSmall(items){    var result = [];    var temp = []    forEach(items, function pushToTemp(item){        temp.push(item);    }); //We don't want to destroy the original array    var sizes = getArrayOfSize(items);    while (temp.length > 0){        var max = getMaxOfArray(sizes);        var index = indexOf(sizes, max);        if (index > -1) {            sizes.splice(index, 1);            result.push(temp[index]);            temp.splice(index, 1);        }    }    return result;}function getArrayOfSize(items){    result = []    forEach(items, function pushSize(item){        result.push(item.Size);    });    return result;}function getSumSize(items){    result = 0;    forEach(items, function addSize(item){        result += item.Size;    });    return result;}function resizeAB(ab, newWidth, newHeight){    var rectObj = rectToObject(ab.artboardRect);    ab.artboardRect = newRect(rectObj.x, -rectObj.y, newWidth, newHeight);    updateArtboardInfo(ab);}function point(x, y) {  this.x = x;  this.y = y;}/*    Inspired by http://www.geeksforgeeks.org/find-two-rectangles-overlap/    I had to modify it to use objects because the rect structures returned from Illustrator are arrays    Tests if two rects are intersecting or not, returns bool*/function doesIntersect(rect1, rect2) {    var r1 = rectToObject(rect1);    var r2 = rectToObject(rect2);    var check1 = true;    var check2 = true;    // If one rectangle is to the right side of the other    if (r1.x > r2.x+r2.width || r2.x > r1.x+r1.width) check1 = false;     // If one rectangle is below the other    if (r1.y < r2.y+r2.height || r2.y < r1.y+r1.height) check2 = false;     return (check1 || check2);}/*    @Param:rect <rect> the input rect to test    @Param:container <rect> the containing rect to hold the input rect*/function willFit(rect, container){    var rectObj = rectToObject(rect);    var containerObj = rectToObject(container);    if (rectObj.Left < containerObj.Left ||        rectObj.Top > containerObj.Top ||        rectObj.Right > containerObj.Right ||        rectObj.Bottom < containerObj.Bottom) return false;    return true;}/* Checks against all known rects    @Param:rect <rect> the rect to test    @Param:takenRects {Array<rect>} array of known rects    @Return:{Array<Bool><int>} false if not free, and index of collision item*/function isPlaceFree(rect, takenRects){    var result = [true, null];    forEach(takenRects, function checkIfFree(testRect, index){        if (doesIntersect(rect, testRect)) result = [false, index];    });    return result;}/*    *@param: ab <artboard>    *@param: index <int> the index of the artboard*/function genSpriteSheet(ab, index){    //Create a Sprite Sheet artboard for this artboard and give it X,Y,Width,Height props    var ssArtboard = newSS_Ab_fromAb(ab, index);    updateArtboardInfo(ssArtboard);    //create a sprite sheet layer if one doesn't exist, and move a grouped copy of all visible layers into this layer    var ssLayer = getSSLayer(ssArtboard);    var ssItems = duplicateVisibleLayersToSSLyr(ssLayer, ssArtboard);    ssLayer.locked = false;    //Give each item X,Y and true Width,Height props    forEach(ssItems, function addProps(item){        updatePageItemInfo(item);        item.Origen = new point(item.X, item.Y);    });    //center each item because translate is a relative oporation    forEach(ssItems, centerItem);        //get an array of the sprite sheet groups ordered from biggest to smallest    var ssItemsBigToSmall = itemsBigToSmall(ssItems);    var lastX2 = ssArtboard.X;    var lastY2 = ssArtboard.Y;    var placedItems = [];    //Make first guess at artboard size    var sumSizes = Math.ceil(getSumSize(ssItems));    resizeAB(ssArtboard, 512, 512);    while (sumSizes > ssArtboard.Width * ssArtboard.Height){        resizeAB(ssArtboard, ssArtboard.Width + 512, ssArtboard.Height + 512);    }    //Move all the pieces onto the artboard Biggest to Smallest    /*NOTE        reverse the array because my forEach function works down the array instead of up        I already tried to fix this but it just causes more problems with the index variable in the callback        Trust me, it's better this way.    */    forEach(reverseArray(ssItemsBigToSmall), function moveToSS(item){        var abRect = ssArtboard.artboardRect;        var spacing = 5;        var startX = ssArtboard.X + spacing;        var startY = ssArtboard.Y - spacing;        var done = false;        forEach(placedItems, function doSomething(placedItem, index){            if (!done){                //Check along Top Right of each placed item                var testRect = newRect(placedItem.Right + spacing, placedItem.Top, item.Width, item.Height);                if (isPlaceFree(testRect, placedItems)){                    var rectObj = rectToObject(testRect);                    startX = rectObj.x;                    startY = -rectObj.y;                    done = true;                }            }        });        item.translate(startX, startY);        updatePageItemInfo(item);        placedItems.push(item);        /*// Check if item will fit        var tempRect = newRect(lastX2, lastY2, item.Width, item.Height);        if (willFit(tempRect, ssArtboard.artboardRect)){            if (isPlaceFree(newRect, placedRects)){                item.translate(lastX2, lastY2);                updatePageItemInfo(item);                lastX2 = item.Right;                lastY2 = item.Bottom;                placedRects.push(tempRect);            } else {            }        }*/    });    alert("I made it this far");    //calculates the best way to fit everything            //update the manafest as it goes}/* manafestItem info:    * @param:layer <int> the layer index for rebuilding properly in flash    * @param:name <string> the layer name    * @param:x <float> the x position of this layer in the document (assuming top-left origin)    * @param:y <float> the y position of this layer in the document (assuming top-left origin)    * @param:ssX <flaot> the x position of this layer in the Sprite Sheet (requires top-left origin)    * @param:ssY <flaot> the y position of this layer in the Sprite Sheet (requires top-left origin)    * @param:width <flaot> the width of the layer in pixels    * @param:height <float> the height of the layer in pixels*/function manafestItem(layer, name, x, y, ssX, ssY, width, height){    this.layer = layer;    this.name = name;    this.x = x;    this.y = y;    this.ssX = ssX;    this.ssY = ssY;    this.width = width;    this.height = height;}