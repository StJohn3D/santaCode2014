#target Illustrator// JSON CODE ///*    json2.js    2014-02-04    Public Domain.    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.    See http://www.JSON.org/js.html    This code should be minified before deployment.    See http://javascript.crockford.com/jsmin.html    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO    NOT CONTROL.    This file creates a global JSON object containing two methods: stringify    and parse.        JSON.stringify(value, replacer, space)            value       any JavaScript value, usually an object or array.            replacer    an optional parameter that determines how object                        values are stringified for objects. It can be a                        function or an array of strings.            space       an optional parameter that specifies the indentation                        of nested structures. If it is omitted, the text will                        be packed without extra whitespace. If it is a number,                        it will specify the number of spaces to indent at each                        level. If it is a string (such as '\t' or '&nbsp;'),                        it contains the characters used to indent at each level.            This method produces a JSON text from a JavaScript value.            When an object value is found, if the object contains a toJSON            method, its toJSON method will be called and the result will be            stringified. A toJSON method does not serialize: it returns the            value represented by the name/value pair that should be serialized,            or undefined if nothing should be serialized. The toJSON method            will be passed the key associated with the value, and this will be            bound to the value            For example, this would serialize Dates as ISO strings.                Date.prototype.toJSON = function (key) {                    function f(n) {                        // Format integers to have at least two digits.                        return n < 10 ? '0' + n : n;                    }                    return this.getUTCFullYear()   + '-' +                         f(this.getUTCMonth() + 1) + '-' +                         f(this.getUTCDate())      + 'T' +                         f(this.getUTCHours())     + ':' +                         f(this.getUTCMinutes())   + ':' +                         f(this.getUTCSeconds())   + 'Z';                };            You can provide an optional replacer method. It will be passed the            key and value of each member, with this bound to the containing            object. The value that is returned from your method will be            serialized. If your method returns undefined, then the member will            be excluded from the serialization.            If the replacer parameter is an array of strings, then it will be            used to select the members to be serialized. It filters the results            such that only members with keys listed in the replacer array are            stringified.            Values that do not have JSON representations, such as undefined or            functions, will not be serialized. Such values in objects will be            dropped; in arrays they will be replaced with null. You can use            a replacer function to replace those with JSON values.            JSON.stringify(undefined) returns undefined.            The optional space parameter produces a stringification of the            value that is filled with line breaks and indentation to make it            easier to read.            If the space parameter is a non-empty string, then that string will            be used for indentation. If the space parameter is a number, then            the indentation will be that many spaces.            Example:            text = JSON.stringify(['e', {pluribus: 'unum'}]);            // text is '["e",{"pluribus":"unum"}]'            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'            text = JSON.stringify([new Date()], function (key, value) {                return this[key] instanceof Date ?                    'Date(' + this[key] + ')' : value;            });            // text is '["Date(---current time---)"]'        JSON.parse(text, reviver)            This method parses a JSON text to produce an object or array.            It can throw a SyntaxError exception.            The optional reviver parameter is a function that can filter and            transform the results. It receives each of the keys and values,            and its return value is used instead of the original value.            If it returns what it received, then the structure is not modified.            If it returns undefined then the member is deleted.            Example:            // Parse the text. Values that look like ISO date strings will            // be converted to Date objects.            myData = JSON.parse(text, function (key, value) {                var a;                if (typeof value === 'string') {                    a =/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);                    if (a) {                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],                            +a[5], +a[6]));                    }                }                return value;            });            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {                var d;                if (typeof value === 'string' &&                        value.slice(0, 5) === 'Date(' &&                        value.slice(-1) === ')') {                    d = new Date(value.slice(5, -1));                    if (d) {                        return d;                    }                }                return value;            });    This is a reference implementation. You are free to copy, modify, or    redistribute.*//*jslint evil: true, regexp: true *//*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,    lastIndex, length, parse, prototype, push, replace, slice, stringify,    test, toJSON, toString, valueOf*/// Create a JSON object only if one does not already exist. We create the// methods in a closure to avoid creating global variables.if (typeof JSON !== 'object') {    JSON = {};}(function () {    'use strict';    function f(n) {        // Format integers to have at least two digits.        return n < 10 ? '0' + n : n;    }    if (typeof Date.prototype.toJSON !== 'function') {        Date.prototype.toJSON = function () {            return isFinite(this.valueOf())                ? this.getUTCFullYear()     + '-' +                    f(this.getUTCMonth() + 1) + '-' +                    f(this.getUTCDate())      + 'T' +                    f(this.getUTCHours())     + ':' +                    f(this.getUTCMinutes())   + ':' +                    f(this.getUTCSeconds())   + 'Z'                : null;        };        String.prototype.toJSON      =            Number.prototype.toJSON  =            Boolean.prototype.toJSON = function () {                return this.valueOf();            };    }    var cx,        escapable,        gap,        indent,        meta,        rep;    function quote(string) {// If the string contains no control characters, no quote characters, and no// backslash characters, then we can safely slap some quotes around it.// Otherwise we must also replace the offending characters with safe escape// sequences.        escapable.lastIndex = 0;        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {            var c = meta[a];            return typeof c === 'string'                ? c                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);        }) + '"' : '"' + string + '"';    }    function str(key, holder) {// Produce a string from holder[key].        var i,          // The loop counter.            k,          // The member key.            v,          // The member value.            length,            mind = gap,            partial,            value = holder[key];// If the value has a toJSON method, call it to obtain a replacement value.        if (value && typeof value === 'object' &&                typeof value.toJSON === 'function') {            value = value.toJSON(key);        }// If we were called with a replacer function, then call the replacer to// obtain a replacement value.        if (typeof rep === 'function') {            value = rep.call(holder, key, value);        }// What happens next depends on the value's type.        switch (typeof value) {        case 'string':            return quote(value);        case 'number':// JSON numbers must be finite. Encode non-finite numbers as null.            return isFinite(value) ? String(value) : 'null';        case 'boolean':        case 'null':// If the value is a boolean or null, convert it to a string. Note:// typeof null does not produce 'null'. The case is included here in// the remote chance that this gets fixed someday.            return String(value);// If the type is 'object', we might be dealing with an object or an array or// null.        case 'object':// Due to a specification blunder in ECMAScript, typeof null is 'object',// so watch out for that case.            if (!value) {                return 'null';            }// Make an array to hold the partial results of stringifying this object value.            gap += indent;            partial = [];// Is the value an array?            if (Object.prototype.toString.apply(value) === '[object Array]') {// The value is an array. Stringify every element. Use null as a placeholder// for non-JSON values.                length = value.length;                for (i = 0; i < length; i += 1) {                    partial[i] = str(i, value) || 'null';                }// Join all of the elements together, separated with commas, and wrap them in// brackets.                v = partial.length === 0                    ? '[]'                    : gap                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'                    : '[' + partial.join(',') + ']';                gap = mind;                return v;            }// If the replacer is an array, use it to select the members to be stringified.            if (rep && typeof rep === 'object') {                length = rep.length;                for (i = 0; i < length; i += 1) {                    if (typeof rep[i] === 'string') {                        k = rep[i];                        v = str(k, value);                        if (v) {                            partial.push(quote(k) + (gap ? ': ' : ':') + v);                        }                    }                }            } else {// Otherwise, iterate through all of the keys in the object.                for (k in value) {                    if (Object.prototype.hasOwnProperty.call(value, k)) {                        v = str(k, value);                        if (v) {                            partial.push(quote(k) + (gap ? ': ' : ':') + v);                        }                    }                }            }// Join all of the member texts together, separated with commas,// and wrap them in braces.            v = partial.length === 0                ? '{}'                : gap                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'                : '{' + partial.join(',') + '}';            gap = mind;            return v;        }    }// If the JSON object does not yet have a stringify method, give it one.    if (typeof JSON.stringify !== 'function') {        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;        meta = {    // table of character substitutions            '\b': '\\b',            '\t': '\\t',            '\n': '\\n',            '\f': '\\f',            '\r': '\\r',            '"' : '\\"',            '\\': '\\\\'        };        JSON.stringify = function (value, replacer, space) {// The stringify method takes a value and an optional replacer, and an optional// space parameter, and returns a JSON text. The replacer can be a function// that can replace values, or an array of strings that will select the keys.// A default replacer method can be provided. Use of the space parameter can// produce text that is more easily readable.            var i;            gap = '';            indent = '';// If the space parameter is a number, make an indent string containing that// many spaces.            if (typeof space === 'number') {                for (i = 0; i < space; i += 1) {                    indent += ' ';                }// If the space parameter is a string, it will be used as the indent string.            } else if (typeof space === 'string') {                indent = space;            }// If there is a replacer, it must be a function or an array.// Otherwise, throw an error.            rep = replacer;            if (replacer && typeof replacer !== 'function' &&                    (typeof replacer !== 'object' ||                    typeof replacer.length !== 'number')) {                throw new Error('JSON.stringify');            }// Make a fake root object containing our value under the key of ''.// Return the result of stringifying the value.            return str('', {'': value});        };    }// If the JSON object does not yet have a parse method, give it one.    if (typeof JSON.parse !== 'function') {        cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;        JSON.parse = function (text, reviver) {// The parse method takes a text and an optional reviver function, and returns// a JavaScript value if the text is a valid JSON text.            var j;            function walk(holder, key) {// The walk method is used to recursively walk the resulting structure so// that modifications can be made.                var k, v, value = holder[key];                if (value && typeof value === 'object') {                    for (k in value) {                        if (Object.prototype.hasOwnProperty.call(value, k)) {                            v = walk(value, k);                            if (v !== undefined) {                                value[k] = v;                            } else {                                delete value[k];                            }                        }                    }                }                return reviver.call(holder, key, value);            }// Parsing happens in four stages. In the first stage, we replace certain// Unicode characters with escape sequences. JavaScript handles many characters// incorrectly, either silently deleting them, or treating them as line endings.            text = String(text);            cx.lastIndex = 0;            if (cx.test(text)) {                text = text.replace(cx, function (a) {                    return '\\u' +                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                });            }// In the second stage, we run the text against regular expressions that look// for non-JSON patterns. We are especially concerned with '()' and 'new'// because they can cause invocation, and '=' because it can cause mutation.// But just to be safe, we want to reject all unexpected forms.// We split the second stage into 4 regexp operations in order to work around// crippling inefficiencies in IE's and Safari's regexp engines. First we// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we// replace all simple value tokens with ']' characters. Third, we delete all// open brackets that follow a colon or comma or that begin the text. Finally,// we look to see that the remaining characters are only whitespace or ']' or// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.            if (/^[\],:{}\s]*$/                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {// In the third stage we use the eval function to compile the text into a// JavaScript structure. The '{' operator is subject to a syntactic ambiguity// in JavaScript: it can begin a block or an object literal. We wrap the text// in parens to eliminate the ambiguity.                j = eval('(' + text + ')');// In the optional fourth stage, we recursively walk the new structure, passing// each name/value pair to a reviver function for possible transformation.                return typeof reviver === 'function'                    ? walk({'': j}, '')                    : j;            }// If the text is not JSON parseable, then a SyntaxError is thrown.            throw new SyntaxError('JSON.parse');        };    }}());// END JSON CODE/* ref code    How to open PS from Illustrator (doesn't work yet with flash)    For reference you can pass in the name of a file too i.e. Ai's active document (t)    //var t = app.activeDocument.fullName;      //photoshop.open(new File(t));    /*var numLayers = doc.layers.length;    var numArtboards = doc.artboards.length;    var rect = doc.artboards[0].artboardRect;    alert(rect);    var width = activeDocument.artboards[0].artboardRect[2];    var height = activeDocument.artboards[0].artboardRect[3];    alert(width + " | " + height);*/var doc, dest, file, manafestFile;var manafestText = "";var manafest = [];var debugMode = false;init();function init(){    //Get all the files we need to work on    file = new File("/Users/sjpeaster/Projects/SantaCode_2014/sourcefiles/illustrator/test.ai");    app.open(file);    //Get the Build folder destination    dest = new File("/Users/sjpeaster/Projects/SantaCode_2014/build");    //Get the active document, alert if there isn't one    resetDoc();    manafestText += ("//----------------  " + doc.name.toUpperCase() + " MANAFEST ----------------//\n\n");    //set reference to manafest file    manafestFile = new File(dest + "/" + doc.name.substring(0,doc.name.length-3) + "_manafest.txt");    //Make a sprite sheet for each artboard    forEach(doc.artboards, genSpriteSheet);    //Save a png for each artboard    forEach(doc.artboards, function savePNG(ab, index){        doc.artboards.setActiveArtboardIndex(index);        toggleSSLayers(ab);        exportPNG(doc, (dest + "/" + ab.name + ".png"), 100);    });    //make a manafest file    manafestFile.open('w');    manafestFile.writeln(manafestText);    doc.close(SaveOptions.DONOTSAVECHANGES);}function toggleSSLayers(ab){    var SS = false;    var nonSS = false;    if (ab.name.match("-SS")) SS = true;    else nonSS = true;    forEach(doc.layers, function toggle(lyr){        if (lyr.name.match("-SS")) lyr.visible = SS;        else lyr.visible = nonSS;    });}function forEach(iterable, callback){    for (var i = iterable.length; i > 0; i--){        var index = i-1;        callback(iterable[index], index);    }}function reverseArray(array){    result = [];    forEach(array, function pushToResult(item){        result.push(item);    });    return result;}function lock(layer){    layer.locked = true;    return layer;}function unlock(layer){    layer.locked = false;    return layer;}function hide(layer){    layer.visible = false;}function show(layer){    layer.visible = true;}function selectAll(layer){    layer.hasSelectedArtwork = false;    layer.hasSelectedArtwork = true;    return doc.selection;}function deselectAll(layer){    layer.hasSelectedArtwork = false;   }function getByName(layers, name){    var result = null;    forEach(layers, function checkName(lyr, index){        if (result != null) return;        if (lyr.name.match(name) != null) result = lyr;    });    return result;}//Set doc to the active document if one existsfunction resetDoc(){    if (app.documents.length > 0){        doc = app.activeDocument;    } else {        alert('Please open an Illustrator file');    }}function exportPNG(doc, dest, scale){    var fileSpec = new File(dest);    var type = ExportType.PNG24;    var exportOptions = new ExportOptionsPNG24();    exportOptions.antiAliasing = false;    exportOptions.artBoardClipping = true;    exportOptions.transparency = true;    exportOptions.saveAsHTML = true;    exportOptions.horizontalScale = scale;    exportOptions.verticalScale = scale;    doc.exportFile( fileSpec, type, exportOptions );}/*Source    *Verry helpful function barrowed from:    *http://greladesign.com/blog/2014/12/03/add-artboard-with-javascript-in-illustrator-cs5-1/*/function newRect(x, y, width, height) {    var l = 0;      var t = 1;      var r = 2;      var b = 3;      var rect = [];      rect[l] = x;      rect[t] = y;      rect[r] = width + x;      rect[b] = y - height;    return rect;  };/* new Sprite Sheet Artboard from Artboard    *@param: ab <artboard>    *@param: index <int> the index of the artboard    *@return: <artboard>*/function newSS_Ab_fromAb(ab, index){    var curRect = ab.artboardRect;    var x = Math.ceil(curRect[0]);    var y = Math.floor(curRect[1]);    var width = Math.ceil(doc.width);    var height = Math.ceil(doc.height);    var name = ab.name;    var result;    //Make sure we have good meaningful names    if(name.match('Artboard') != null){        name = doc.name.substr(0, doc.name.length-3) + "_Ab" + index;        ab.name = name;    }    //creates a new artboard with special name    if(doc.artboards.length < 100) result = doc.artboards.add(newRect(x + width + 10, -y, width, height));    else {        alert("Too many artboards in this document."        + "\nCannot create a sprite sheet until you remove at least one artboard.");    }    result.name = name + "-SS";    return result;}/* Get's the sprite sheet layer, makes one if there isn't one yet    *@param: ssArtboard <Artboard> the Sprite Sheet Artboard    *@return: <Layer>*/function getSSLayer(ssArtboard){    var result;    if(getByName(doc.layers, ssArtboard.name) == null){        result = doc.layers.add();        result.name = ssArtboard.name;          }else{        result = getByName(doc.layers, ssArtboard.name);    }    return result;}/* Duplicates each layer's contents to a group in the SSLayer    *@param: ssLayer <Layer> the Sprite Sheet Layer    *@param: ssArtboard <Artboard> the Sprite Sheet Artboard    *@return: <Array>*/function duplicateVisibleLayersToSSLyr(ssLayer, ssArtboard){    var result = [];    var layers = doc.layers;    forEach(layers, lock);    forEach(layers, function duplicateContentsTo(lyr, index){        //NOTE!! There is no way to manipulate effects from Illustrator through js        //IT WILL ONLY KEEP EFFECTS APPLIED TO GROUPS WITHIN A LAYER ^^^        //skip if sprite sheet layer TODO        if (!lyr.visible || lyr.name == ssArtboard.name) return;        lyr.locked = false;        var lyrContents = lyr.pageItems;        ssLayer.locked = false;        //TODO Pop these groups into an array        var newGroup = ssLayer.groupItems.add();        newGroup.name = lyr.name + "_Grp";                for ( i = 0; i < lyrContents.length; i++ ) {            newItem = lyrContents[i].duplicate();            newItem.moveToEnd( newGroup );        }        result.push(newGroup);        ssLayer.locked = true;        lyr.locked = true;    });    return result;}function rectToObject(rect){    var result = new Object;    result.Left = rect[0];    result.Top = rect[1];    result.Right = rect[2];    result.Bottom = rect[3];    result.X = rect[0];    result.Y = rect[1];    result.Width = Math.abs(result.Right - result.X);    result.Height = Math.abs(result.Bottom - result.Top);    if (result.Left > result.Right || result.Top < result.Bottom) debug("ERROR\n\nInvalid rect object created!");    return result;}function updateArtboardInfo(artboard){    var rectObj = rectToObject(artboard.artboardRect);    artboard.Left = rectObj.Left;    artboard.Top = rectObj.Top;    artboard.Right = rectObj.Right;    artboard.Bottom = rectObj.Bottom;    artboard.X = rectObj.X;    artboard.Y = rectObj.Y;    artboard.Width = rectObj.Width;    artboard.Height = rectObj.Height;    artboard.Size = rectObj.Width * rectObj.Height;}function updatePageItemInfo(pageItem){    //PageItem width/height props do no include strokes    var rectObj = rectToObject(pageItem.controlBounds);    pageItem.Left = rectObj.Left;    pageItem.Top = rectObj.Top;    pageItem.Right = rectObj.Right;    pageItem.Bottom = rectObj.Bottom;    pageItem.X = rectObj.X;    pageItem.Y = rectObj.Y;    pageItem.Width = rectObj.Width;    pageItem.Height = rectObj.Height;    pageItem.Size = rectObj.Width * rectObj.Height;}function centerItem(pageItem){    //Assumes X/Y props are updated    pageItem.translate(-pageItem.X,-pageItem.Y);}function getMaxOfArray(numArray) {    return Math.max.apply(null, numArray);}function indexOf(iterable, item){    var result = -1;    forEach(iterable, function checkForMatch(thisItem, index){        if (result > -1) return;        if (thisItem == item) result = index;    });    return result;}function biggestToSmallest(numArray){    var result = [];    while (numArray.length > 0){        var max = getMaxOfArray(numArray);        var index = indexOf(numArray, max);        if (index > -1) {            numArray.splice(index, 1);            result.push(numArray[index]);        }    }    return result;}function itemsBigToSmall(items){    var result = [];    var temp = []    forEach(items, function pushToTemp(item){        temp.push(item);    }); //We don't want to destroy the original array    var sizes = getArrayOfSize(items);    while (temp.length > 0){        var max = getMaxOfArray(sizes);        var index = indexOf(sizes, max);        if (index > -1) {            sizes.splice(index, 1);            result.push(temp[index]);            temp.splice(index, 1);        }    }    return result;}function getArrayOfSize(items){    result = [];    forEach(items, function pushSize(item){        result.push(item.Size);    });    return result;}function getArrayOfRect(items){    result = [];    forEach(items, function pushRect(item){        result.push(item.controlBounds);    });    return result;}function getSumSize(items){    result = 0;    forEach(items, function addSize(item){        result += item.Size;    });    return result;}function resizeAB(ab, newWidth, newHeight){    var rectObj = rectToObject(ab.artboardRect);    ab.artboardRect = newRect(rectObj.X, -rectObj.Y, newWidth, newHeight);    updateArtboardInfo(ab);}function point(x, y) {  this.x = x;  this.y = y;}/*    Inspired by http://www.geeksforgeeks.org/find-two-rectangles-overlap/    I had to modify it to use objects because the rect structures returned from Illustrator are arrays    Tests if two rects are intersecting or not, returns bool*/function doesIntersect(obj1, obj2) {    var check1 = true;    var check2 = true;    // If one rectangle is to the right side of the other    if (obj1.Left > obj2.Right || obj2.Left > obj1.Right) check1 = false;     // If one rectangle is below the other    if (obj1.Top < obj2.Bottom || obj2.Top < obj1.Bottom) check2 = false;     return (check1 && check2);}/*    @Param:rect <rect> the input rect to test    @Param:container <rect> the containing rect to hold the input rect*/function willFit(rect, container){ //TODO - Doesn't seam to work right; Change to just take objects    var rectObj = rectToObject(rect);    var containerObj = rectToObject(container);    return (rectObj.Left > containerObj.Left &&        rectObj.Top < containerObj.Top &&        rectObj.Right < containerObj.Right &&        rectObj.Bottom > containerObj.Bottom);}/* Checks against all known rects TODO - Update params; it takes objects now    @Param:rect <rect> the rect to test    @Param:takenRects {Array<rect>} array of known rects    @Return:{Array<Bool><int>} false if not free, and index of collision item*/function isPlaceFree(object, knownObjects){    var result = [true, null, ""];    forEach(knownObjects, function checkIfFree(knownObject, index){        if (result[0]){            if (doesIntersect(object, knownObject)) result = [false, index, knownObject.name];            debug("checking " + object.name + " against " + knownObject.name + "\n\n" + result);        }    });    return result;}/*    *@param: ab <artboard>    *@param: index <int> the index of the artboard*/function genSpriteSheet(ab, index){    //Create a Sprite Sheet artboard for this artboard and give it X,Y,Width,Height props    var ssArtboard = newSS_Ab_fromAb(ab, index);    updateArtboardInfo(ssArtboard);    var manafestObj = new manafestEntry(ab, ssArtboard);    //create a sprite sheet layer if one doesn't exist, and move a grouped copy of all visible layers into this layer    var ssLayer = getSSLayer(ssArtboard);    var ssItems = duplicateVisibleLayersToSSLyr(ssLayer, ssArtboard);    ssLayer.locked = false;    //Give each item X,Y and true Width,Height props    forEach(ssItems, function addProps(item, index){        updatePageItemInfo(item);        item.Origen = new point(item.X, item.Y);        item.Layer = index;    });    //center each item because translate is a relative oporation    forEach(ssItems, centerItem);        //get an array of the sprite sheet groups ordered from biggest to smallest    var ssItemsBigToSmall = itemsBigToSmall(ssItems);    //Make first guess at artboard size    var sumSizes = Math.ceil(getSumSize(ssItems));    resizeAB(ssArtboard, 512, 512);    while (sumSizes > ssArtboard.Width * ssArtboard.Height){        resizeAB(ssArtboard, ssArtboard.Width + 512, ssArtboard.Height + 512);    }    //Move all the pieces onto the artboard Biggest to Smallest    /*NOTE        reverse the array because my forEach function works down the array instead of up        I already tried to fix this but it just causes more problems with the index variable in the callback        Trust me, it's better this way.    */    var placedItems = [];    forEach(reverseArray(ssItemsBigToSmall), function moveToSS(item){        var spacing = 5;        var startX = ssArtboard.X + spacing;        var startY = ssArtboard.Y - spacing;        var done = false;        //calculates the best way to fit everything        forEach(placedItems, function WorkAlongTopRight(placedItem, index){            if (!done){                debug("looking along x2y1 " + item.name);                //Check along Top Right of each placed item                var newRectObj = rectToObject(newRect(placedItem.Right + spacing, placedItem.Top, item.Width, item.Height));                debug("Does it fit in X?\n\nartboardRight " + ssArtboard.Right + "\n\nnewRectRight " + newRectObj.Right);                if (ssArtboard.Right > newRectObj.Right) { //Check if it will fit in the artboard first                    if (isPlaceFree(newRectObj, placedItems)[0]){ //check if place is free                        debug("1st " + item.name);                        startX = newRectObj.X;                        startY = newRectObj.Y;                        done = true;                    }                }            }        });        forEach(reverseArray(placedItems), function WorkAlongBottomLeft(placedItem, index){            if (!done){                debug("looking AGAIN along x1y2 " + item.name);                //Check along Bottom Left of each placed item                var newRectObj = rectToObject(newRect(placedItem.Left, placedItem.Bottom - spacing, item.Width, item.Height));                if (isPlaceFree(newRectObj, placedItems)[0]){ //THIS IS THE PROBLEM!!!! <-------------                    debug("2nd " + item.name);                    startX = newRectObj.X;                    startY = newRectObj.Y;                    debug("Does it fit in Y?\n\nartboardBottom " + ssArtboard.Bottom + "\n\nnewRectBottom " + newRectObj.Bottom);                    done = true;                }            }        });        if (!done) debug("error! something didn't fit anywhere");        item.translate(startX, startY);        debug("Placed " + item.name);        updatePageItemInfo(item);        placedItems.push(item);        manafestObj.items.push(new manafestItem(item.name,            item.Layer,            item.Origen.x,            item.Origen.y,            item.X,            item.Y,            item.Width - ssArtboard.X,            item.Height + ssArtboard.Y        ));    });    manafest.push(manafestObj);    manafestText += (JSON.stringify(manafest, replacer, 4));}function manafestEntry(ab, ssArtboard){    manafestText += ("// File: " + doc.name + " | Artboard: " + ab.name + " - Sprite Sheet Manafest (" + ssArtboard.name + ")\n");    this.name = ssArtboard.name;    this.items = [];}function replacer(key, value){    return value;};/* manafestItem info:    * @param:layer <int> the layer index for rebuilding properly in flash    * @param:name <string> the layer name    * @param:x <float> the x position of this layer in the document (assuming top-left origin)    * @param:y <float> the y position of this layer in the document (assuming top-left origin)    * @param:ssX <flaot> the x position of this layer in the Sprite Sheet (requires top-left origin)    * @param:ssY <flaot> the y position of this layer in the Sprite Sheet (requires top-left origin)    * @param:width <flaot> the width of the layer in pixels    * @param:height <float> the height of the layer in pixels*/function manafestItem(name, layer, x, y, ssX, ssY, width, height){    this.name = name;    this.layer = layer;    this.x = x;    this.y = y;    this.ssX = ssX;    this.ssY = ssY;    this.width = width;    this.height = height;}function debug(string){    if (debugMode){        alert(string);    }}