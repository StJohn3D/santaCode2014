#target Illustrator/* ref code    How to open PS from Illustrator (doesn't work yet with flash)    For reference you can pass in the name of a file too i.e. Ai's active document (t)    //var t = app.activeDocument.fullName;      //photoshop.open(new File(t));    /*var numLayers = doc.layers.length;    var numArtboards = doc.artboards.length;    var rect = doc.artboards[0].artboardRect;    alert(rect);    var width = activeDocument.artboards[0].artboardRect[2];    var height = activeDocument.artboards[0].artboardRect[3];    alert(width + " | " + height);*/var doc, dest, file;var manafest = [];var debugMode = false;init();function init(){    //Get all the files we need to work on    file = new File("/Users/sjpeaster/Projects/SantaCode_2014/sourcefiles/illustrator/test.ai");    app.open(file);    //Get the Build folder destination    dest = new File("/Users/sjpeaster/Projects/SantaCode_2014/build");    //Get the active document, alert if there isn't one    resetDoc();    //Make a sprite sheet for each artboard (TODO - Ensure that sprite sheets are created in a 'free' space);    forEach(doc.artboards, genSpriteSheet);    //Save a png for each artboard    forEach(doc.artboards, function savePNG(ab, index){        doc.artboards.setActiveArtboardIndex(index);        toggleSSLayers(ab);        exportPNG(doc, (dest + "/" + ab.name + ".png"), 100);    });    doc.close(SaveOptions.DONOTSAVECHANGES);}function toggleSSLayers(ab){    var SS = false;    var nonSS = false;    if (ab.name.match("-SS")) SS = true;    else nonSS = true;    forEach(doc.layers, function toggle(lyr){        if (lyr.name.match("-SS")) lyr.visible = SS;        else lyr.visible = nonSS;    });}function forEach(iterable, callback){    for (var i = iterable.length; i > 0; i--){        var index = i-1;        callback(iterable[index], index);    }}function reverseArray(array){    result = [];    forEach(array, function pushToResult(item){        result.push(item);    });    return result;}function lock(layer){    layer.locked = true;    return layer;}function unlock(layer){    layer.locked = false;    return layer;}function hide(layer){    layer.visible = false;}function show(layer){    layer.visible = true;}function selectAll(layer){    layer.hasSelectedArtwork = false;    layer.hasSelectedArtwork = true;    return doc.selection;}function deselectAll(layer){    layer.hasSelectedArtwork = false;   }function getByName(layers, name){    var result = null;    forEach(layers, function checkName(lyr, index){        if (result != null) return;        if (lyr.name.match(name) != null) result = lyr;    });    return result;}//Set doc to the active document if one existsfunction resetDoc(){    if (app.documents.length > 0){        doc = app.activeDocument;    } else {        alert('Please open an Illustrator file');    }}function exportPNG(doc, dest, scale){    var fileSpec = new File(dest);    var type = ExportType.PNG24;    var exportOptions = new ExportOptionsPNG24();    exportOptions.antiAliasing = false;    exportOptions.artBoardClipping = true;    exportOptions.transparency = true;    exportOptions.saveAsHTML = true;    exportOptions.horizontalScale = scale;    exportOptions.verticalScale = scale;    doc.exportFile( fileSpec, type, exportOptions );}/*Source    *Verry helpful function barrowed from:    *http://greladesign.com/blog/2014/12/03/add-artboard-with-javascript-in-illustrator-cs5-1/*/function newRect(x, y, width, height) {    var l = 0;      var t = 1;      var r = 2;      var b = 3;      var rect = [];      rect[l] = x;      rect[t] = y;      rect[r] = width + x;      rect[b] = y - height;    return rect;  };/* new Sprite Sheet Artboard from Artboard    *@param: ab <artboard>    *@param: index <int> the index of the artboard    *@return: <artboard>*/function newSS_Ab_fromAb(ab, index){    var curRect = ab.artboardRect;    var x = Math.ceil(curRect[0]);    var y = Math.floor(curRect[1]);    var width = Math.ceil(doc.width);    var height = Math.ceil(doc.height);    var name = ab.name;    var result;    //Make sure we have good meaningful names    if(name.match('Artboard') != null){        name = doc.name.substr(0, doc.name.length-3) + "_Ab" + index;        ab.name = name;    }    //creates a new artboard with special name    if(doc.artboards.length < 100) result = doc.artboards.add(newRect(x + width + 10, -y, width, height));    else {        alert("Too many artboards in this document."        + "\nCannot create a sprite sheet until you remove at least one artboard.");    }    result.name = name + "-SS";    return result;}/* Get's the sprite sheet layer, makes one if there isn't one yet    *@param: ssArtboard <Artboard> the Sprite Sheet Artboard    *@return: <Layer>*/function getSSLayer(ssArtboard){    var result;    if(getByName(doc.layers, ssArtboard.name) == null){        result = doc.layers.add();        result.name = ssArtboard.name;          }else{        result = getByName(doc.layers, ssArtboard.name);    }    return result;}/* Duplicates each layer's contents to a group in the SSLayer    *@param: ssLayer <Layer> the Sprite Sheet Layer    *@param: ssArtboard <Artboard> the Sprite Sheet Artboard    *@return: <Array>*/function duplicateVisibleLayersToSSLyr(ssLayer, ssArtboard){    var result = [];    var layers = doc.layers;    forEach(layers, lock);    forEach(layers, function duplicateContentsTo(lyr, index){        //NOTE!! There is no way to manipulate effects from Illustrator through js        //IT WILL ONLY KEEP EFFECTS APPLIED TO GROUPS WITHIN A LAYER ^^^        //skip if sprite sheet layer TODO        if (!lyr.visible || lyr.name == ssArtboard.name) return;        lyr.locked = false;        var lyrContents = lyr.pageItems;        ssLayer.locked = false;        //TODO Pop these groups into an array        var newGroup = ssLayer.groupItems.add();        newGroup.name = lyr.name + "_Grp";                for ( i = 0; i < lyrContents.length; i++ ) {            newItem = lyrContents[i].duplicate();            newItem.moveToEnd( newGroup );        }        result.push(newGroup);        ssLayer.locked = true;        lyr.locked = true;    });    return result;}function rectToObject(rect){    var result = new Object;    result.Left = rect[0];    result.Top = rect[1];    result.Right = rect[2];    result.Bottom = rect[3];    result.X = rect[0];    result.Y = rect[1];    result.Width = Math.abs(result.Right - result.X);    result.Height = Math.abs(result.Bottom - result.Top);    if (result.Left > result.Right || result.Top < result.Bottom) debug("ERROR\n\nInvalid rect object created!");    return result;}function updateArtboardInfo(artboard){    var rectObj = rectToObject(artboard.artboardRect);    artboard.Left = rectObj.Left;    artboard.Top = rectObj.Top;    artboard.Right = rectObj.Right;    artboard.Bottom = rectObj.Bottom;    artboard.X = rectObj.X;    artboard.Y = rectObj.Y;    artboard.Width = rectObj.Width;    artboard.Height = rectObj.Height;    artboard.Size = rectObj.Width * rectObj.Height;}function updatePageItemInfo(pageItem){    //PageItem width/height props do no include strokes    var rectObj = rectToObject(pageItem.controlBounds);    pageItem.Left = rectObj.Left;    pageItem.Top = rectObj.Top;    pageItem.Right = rectObj.Right;    pageItem.Bottom = rectObj.Bottom;    pageItem.X = rectObj.X;    pageItem.Y = rectObj.Y;    pageItem.Width = rectObj.Width;    pageItem.Height = rectObj.Height;    pageItem.Size = rectObj.Width * rectObj.Height;}function centerItem(pageItem){    //Assumes X/Y props are updated    pageItem.translate(-pageItem.X,-pageItem.Y);}function getMaxOfArray(numArray) {    return Math.max.apply(null, numArray);}function indexOf(iterable, item){    var result = -1;    forEach(iterable, function checkForMatch(thisItem, index){        if (result > -1) return;        if (thisItem == item) result = index;    });    return result;}function biggestToSmallest(numArray){    var result = [];    while (numArray.length > 0){        var max = getMaxOfArray(numArray);        var index = indexOf(numArray, max);        if (index > -1) {            numArray.splice(index, 1);            result.push(numArray[index]);        }    }    return result;}function itemsBigToSmall(items){    var result = [];    var temp = []    forEach(items, function pushToTemp(item){        temp.push(item);    }); //We don't want to destroy the original array    var sizes = getArrayOfSize(items);    while (temp.length > 0){        var max = getMaxOfArray(sizes);        var index = indexOf(sizes, max);        if (index > -1) {            sizes.splice(index, 1);            result.push(temp[index]);            temp.splice(index, 1);        }    }    return result;}function getArrayOfSize(items){    result = [];    forEach(items, function pushSize(item){        result.push(item.Size);    });    return result;}function getArrayOfRect(items){    result = [];    forEach(items, function pushRect(item){        result.push(item.controlBounds);    });    return result;}function getSumSize(items){    result = 0;    forEach(items, function addSize(item){        result += item.Size;    });    return result;}function resizeAB(ab, newWidth, newHeight){    var rectObj = rectToObject(ab.artboardRect);    ab.artboardRect = newRect(rectObj.X, -rectObj.Y, newWidth, newHeight);    updateArtboardInfo(ab);}function point(x, y) {  this.x = x;  this.y = y;}/*    Inspired by http://www.geeksforgeeks.org/find-two-rectangles-overlap/    I had to modify it to use objects because the rect structures returned from Illustrator are arrays    Tests if two rects are intersecting or not, returns bool*/function doesIntersect(obj1, obj2) {    var check1 = true;    var check2 = true;    // If one rectangle is to the right side of the other    if (obj1.Left > obj2.Right || obj2.Left > obj1.Right) check1 = false;     // If one rectangle is below the other    if (obj1.Top < obj2.Bottom || obj2.Top < obj1.Bottom) check2 = false;     return (check1 && check2);}/*    @Param:rect <rect> the input rect to test    @Param:container <rect> the containing rect to hold the input rect*/function willFit(rect, container){ //TODO - Doesn't seam to work right; Change to just take objects    var rectObj = rectToObject(rect);    var containerObj = rectToObject(container);    return (rectObj.Left > containerObj.Left &&        rectObj.Top < containerObj.Top &&        rectObj.Right < containerObj.Right &&        rectObj.Bottom > containerObj.Bottom);}/* Checks against all known rects TODO - Update params; it takes objects now    @Param:rect <rect> the rect to test    @Param:takenRects {Array<rect>} array of known rects    @Return:{Array<Bool><int>} false if not free, and index of collision item*/function isPlaceFree(object, knownObjects){    var result = [true, null, ""];    forEach(knownObjects, function checkIfFree(knownObject, index){        if (result[0]){            if (doesIntersect(object, knownObject)) result = [false, index, knownObject.name];            debug("checking " + object.name + " against " + knownObject.name + "\n\n" + result);        }    });    return result;}/*    *@param: ab <artboard>    *@param: index <int> the index of the artboard*/function genSpriteSheet(ab, index){    //Create a Sprite Sheet artboard for this artboard and give it X,Y,Width,Height props    var ssArtboard = newSS_Ab_fromAb(ab, index);    updateArtboardInfo(ssArtboard);    //create a sprite sheet layer if one doesn't exist, and move a grouped copy of all visible layers into this layer    var ssLayer = getSSLayer(ssArtboard);    var ssItems = duplicateVisibleLayersToSSLyr(ssLayer, ssArtboard);    ssLayer.locked = false;    //Give each item X,Y and true Width,Height props    forEach(ssItems, function addProps(item){        updatePageItemInfo(item);        item.Origen = new point(item.X, item.Y);    });    //center each item because translate is a relative oporation    forEach(ssItems, centerItem);        //get an array of the sprite sheet groups ordered from biggest to smallest    var ssItemsBigToSmall = itemsBigToSmall(ssItems);    //Make first guess at artboard size    var sumSizes = Math.ceil(getSumSize(ssItems));    resizeAB(ssArtboard, 512, 512);    while (sumSizes > ssArtboard.Width * ssArtboard.Height){        resizeAB(ssArtboard, ssArtboard.Width + 512, ssArtboard.Height + 512);    }    //Move all the pieces onto the artboard Biggest to Smallest    /*NOTE        reverse the array because my forEach function works down the array instead of up        I already tried to fix this but it just causes more problems with the index variable in the callback        Trust me, it's better this way.    */    var placedItems = [];    forEach(reverseArray(ssItemsBigToSmall), function moveToSS(item){        var spacing = 5;        var startX = ssArtboard.X + spacing;        var startY = ssArtboard.Y - spacing;        var done = false;        //calculates the best way to fit everything        forEach(placedItems, function WorkAlongTopRight(placedItem, index){            if (!done){                debug("looking along x2y1 " + item.name);                //Check along Top Right of each placed item                var newRectObj = rectToObject(newRect(placedItem.Right + spacing, placedItem.Top, item.Width, item.Height));                debug("Does it fit in X?\n\nartboardRight " + ssArtboard.Right + "\n\nnewRectRight " + newRectObj.Right);                if (ssArtboard.Right > newRectObj.Right) { //Check if it will fit in the artboard first                    if (isPlaceFree(newRectObj, placedItems)[0]){ //check if place is free                        debug("1st " + item.name);                        startX = newRectObj.X;                        startY = newRectObj.Y;                        done = true;                    }                }            }        });        forEach(reverseArray(placedItems), function WorkAlongBottomLeft(placedItem, index){            if (!done){                debug("looking AGAIN along x1y2 " + item.name);                //Check along Bottom Left of each placed item                var newRectObj = rectToObject(newRect(placedItem.Left, placedItem.Bottom - spacing, item.Width, item.Height));                if (isPlaceFree(newRectObj, placedItems)[0]){ //THIS IS THE PROBLEM!!!! <-------------                    debug("2nd " + item.name);                    startX = newRectObj.X;                    startY = newRectObj.Y;                    debug("Does it fit in Y?\n\nartboardBottom " + ssArtboard.Bottom + "\n\nnewRectBottom " + newRectObj.Bottom);                    done = true;                }            }        });        if (!done) debug("error! something didn't fit anywhere");        item.translate(startX, startY);        debug("Placed " + item.name);        updatePageItemInfo(item);        placedItems.push(item);    });            //update the manafest as it goes}/* manafestItem info:    * @param:layer <int> the layer index for rebuilding properly in flash    * @param:name <string> the layer name    * @param:x <float> the x position of this layer in the document (assuming top-left origin)    * @param:y <float> the y position of this layer in the document (assuming top-left origin)    * @param:ssX <flaot> the x position of this layer in the Sprite Sheet (requires top-left origin)    * @param:ssY <flaot> the y position of this layer in the Sprite Sheet (requires top-left origin)    * @param:width <flaot> the width of the layer in pixels    * @param:height <float> the height of the layer in pixels*/function manafestItem(layer, name, x, y, ssX, ssY, width, height){    this.layer = layer;    this.name = name;    this.x = x;    this.y = y;    this.ssX = ssX;    this.ssY = ssY;    this.width = width;    this.height = height;}function debug(string){    if (debugMode){        alert(string);    }}